---
slug: "rails-replication"
title: "Репликация данных"
description: "Репликация - прием масштабирования базы данных, когда данные с одного сервера бд (master) постоянно копируются (реплицируются) на другой (slave), благодаря этому возможно распределить нагрузку между серверами."
summary: "Репликация - прием масштабирования базы данных, когда данные с одного сервера бд (master) постоянно копируются (реплицируются) на другой (slave), благодаря этому возможно распределить нагрузку между серверами."
image: "/posts/replication.png"
date: 2021-11-08
lastmod: 2021-11-08
draft: false
weight: 50
categories: []
tags: [perfomance ruby rails db]
pinned: false
homepage: false
seo:
  title: "Репликация данных"
  description: "Репликация данных - это утилита для тестирования производительности вашего веб-сервера Apache. Она создана для того, чтобы вы могли определить производительность вашей текущей настройки Apache."
---

![Репликация](/posts/replication.png "Репликация")

### Что такое Репликация?
Репликация - прием масштабирования базы данных, когда данные с одного сервера бд (_master_) постоянно копируются (реплицируются) на другой (_slave_), благодаря этому у приложения появляется возможность работать с несколькими серверами, например разделить запросы для записи и чтения, разделяя нагрузку.

Существует два основных подхода при работе с репликацией данных: _Master - Slave_ и _Master - Master_.

### Master-Slave репликация
В этом подходе выделяется один основной сервер базы данных, который называется мастером. На нем происходят все изменения в данных (любые запросы _INSERT/UPDATE/DELETE_). _Slave_ сервер постоянно копирует все изменения с _master_. С приложения на _slave_ сервер отправляются запросы чтения данных (запросы _SELECT_). 

Таким образом _master_ сервер отвечает - за изменения данных, а _slave_ - за чтение.

##### Несколько Слейвов
Преимущество этого типа репликации в том, что Вы можете использовать более одного _slave_. Обычно следует использовать не более 20 _slave) серверов при работе с одним мастером.

Например, создание нескольких дополнительных _slave_-серверов позволяет снять с основного сервера нагрузку и повысить общую производительность системы, а также можно организовать слэйвы под конкретные ресурсоёмкие задачи и таким образом, например, упростить составление серьёзных аналитических отчётов - используемый для этих целей _slave_ может быть нагружен на 100%, но на работу других пользователей приложения это не повлияет.

##### Задержка репликации
Асинхронность репликации означает, что данные на _slave_ могут появиться с небольшой задержкой. Поэтому, в последовательных операциях необходимо использовать чтение с _master_, чтобы получить актуальные данные.

### Пример работы в Rails 6

Для начала в _database.yml_ добавьте данные _primary_ и _primary_replica_.
```ruby
default: &default
  host: <%= ENV['DATABASE_HOST'] %>
  port: 5432
  adapter: postgresql
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  database: <%= ENV['DATABASE_NAME'] %>
  username: <%= ENV['DATABASE_USER'] %>
  password: <%= ENV['DATABASE_PASSWORD'] %>

production:
  primary:
    <<: *default
  primary_replica:
    <<: *default
    host: <%= ENV['DATABASE_HOST_REPLICA'] %>
    replica: true
```

В _application_record.rb_ добавьте (у меня только для окружения _production_):
```ruby
connects_to database: { writing: :primary, reading: :primary_replica } if Rails.env.production? 
```

Настроим активацию автоматического переключения соединения в _production.rb_:
```ruby
config.active_record.database_selector = { delay: 2.seconds }
config.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver
config.active_record.database_resolver_context = ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
```

- Наконец, чтобы использовать реплику только для чтения в вашем приложении, вам необходимо активировать промежуточное программное обеспечение для автоматического переключения.

- Автоматическое переключение позволяет приложению переключаться с модуля записи на реплику или от реплики к записи в зависимости от HTTP-команды и того, была ли последняя запись.

- Если приложение получает запрос _POST, PUT, DELETE_ или _PATCH_, приложение автоматически выполнит запись в базу данных записи. В течение указанного времени после записи приложение будет читать с основного. Для запроса _GET_ или _HEAD_ приложение будет читать из реплики, если не было недавней записи.

- Чтобы активировать промежуточное ПО для автоматического переключения соединений, добавьте или раскомментируйте следующие строки в конфигурации вашего приложения.